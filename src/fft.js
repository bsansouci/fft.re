// Generated by BUCKLESCRIPT VERSION 3.2.0, PLEASE EDIT WITH CARE

import * as Complex from "bs-platform/lib/es6/complex.js";
import * as BigarrayJs from "./js/BigarrayJs.js";
import * as MyBigarray from "./MyBigarray.js";

var pi = 4.0 * Math.atan(1.0);

var two_pi = pi * 2;

function fftInplace(complex) {
  var m = complex.length / 2 | 0;
  var evenElements = BigarrayJs.Array1[/* create */0](MyBigarray.complex64, MyBigarray.c_layout, m);
  var oddElements = BigarrayJs.Array1[/* create */0](MyBigarray.complex64, MyBigarray.c_layout, m);
  for(var k = 0 ,k_finish = m - 1 | 0; k <= k_finish; ++k){
    evenElements[k] = complex[(k << 1)];
    oddElements[k] = complex[(k << 1) + 1 | 0];
  }
  if (m > 1) {
    fftInplace(evenElements);
    fftInplace(oddElements);
  }
  for(var k$1 = 0 ,k_finish$1 = m - 1 | 0; k$1 <= k_finish$1; ++k$1){
    var a = -pi * k$1 / m;
    var x = Math.cos(a);
    var y = Math.sin(a);
    var com = oddElements[k$1];
    var new_com_000 = /* re */x * com[/* re */0] - y * com[/* im */1];
    var new_com_001 = /* im */x * com[/* im */1] + y * com[/* re */0];
    var new_com = /* record */[
      new_com_000,
      new_com_001
    ];
    var c = evenElements[k$1];
    complex[k$1] = Complex.add(c, new_com);
    complex[k$1 + m | 0] = Complex.sub(c, new_com);
  }
  return /* () */0;
}

function fft(data, maxAmplitude, _) {
  var m = data.length;
  var data_cp = BigarrayJs.Array1[/* create */0](MyBigarray.complex64, MyBigarray.c_layout, m);
  BigarrayJs.Array1[/* blit */1](data, data_cp);
  fftInplace(data_cp);
  var maxAmplitudeFrequency = 0;
  var spectrum = BigarrayJs.Array1[/* create */0](MyBigarray.float64, MyBigarray.c_layout, m);
  for(var i = 0 ,i_finish = m - 1 | 0; i <= i_finish; ++i){
    spectrum[i] = Complex.norm(data_cp[i]);
    if (spectrum[i] > maxAmplitudeFrequency) {
      maxAmplitudeFrequency = spectrum[i];
    }
    
  }
  for(var i$1 = 0 ,i_finish$1 = m - 1 | 0; i$1 <= i_finish$1; ++i$1){
    spectrum[i$1] = spectrum[i$1] / maxAmplitudeFrequency * maxAmplitude;
  }
  return spectrum;
}

function hannWindow(data) {
  var bucketSize = data.length;
  var total = bucketSize - 1 | 0;
  for(var i = 0 ,i_finish = bucketSize - 1 | 0; i <= i_finish; ++i){
    var multiplier = 0.5 - 0.5 * Math.cos(two_pi * i / total);
    var com = data[i];
    data[i] = /* record */[
      /* re */com[/* re */0] * multiplier,
      /* im */com[/* im */1]
    ];
  }
  return /* () */0;
}

function hammingWindow(data) {
  var bucketSize = data.length;
  var total = bucketSize - 1 | 0;
  for(var i = 0 ,i_finish = bucketSize - 1 | 0; i <= i_finish; ++i){
    var multiplier = 0.54 - 0.46 * Math.cos(two_pi * i / total);
    var com = data[i];
    data[i] = /* record */[
      /* re */com[/* re */0] * multiplier,
      /* im */com[/* im */1]
    ];
  }
  return /* () */0;
}

function getMaxAmplitude(data) {
  var maxAmplitude = 0;
  var size = data.length;
  for(var i = 0 ,i_finish = size - 1 | 0; i <= i_finish; ++i){
    var x = data[i];
    if (x[/* re */0] > maxAmplitude) {
      maxAmplitude = x[/* re */0];
    }
    
  }
  return maxAmplitude;
}

function generateSineInplace(data, frequency, samplingRate, $staropt$star, $staropt$star$1, _) {
  var offset = $staropt$star ? $staropt$star[0] : 0;
  var numberOfSines = $staropt$star$1 ? $staropt$star$1[0] : 1;
  var size = data.length;
  var samplingRatef = samplingRate;
  for(var i = 0 ,i_finish = size - 1 | 0; i <= i_finish; ++i){
    var x = 0;
    for(var k = 0 ,k_finish = numberOfSines - 1 | 0; k <= k_finish; ++k){
      var coef = (k << 1) + 1 | 0;
      x += (Math.sin(offset * coef + i * frequency * coef / samplingRatef * pi * 2) / coef);
    }
    data[i] = /* record */[
      /* re */x,
      /* im */0
    ];
  }
  return /* () */0;
}

function generateSine(frequency, $staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, _) {
  var samplingRate = $staropt$star ? $staropt$star[0] : 256;
  var size = $staropt$star$1 ? $staropt$star$1[0] : 256;
  var offset = $staropt$star$2 ? $staropt$star$2[0] : 0;
  var numberOfSines = $staropt$star$3 ? $staropt$star$3[0] : 1;
  var data = BigarrayJs.Array1[/* create */0](MyBigarray.complex64, MyBigarray.c_layout, size);
  generateSineInplace(data, frequency, samplingRate, /* Some */[offset], /* Some */[numberOfSines], /* () */0);
  return data;
}

var BA = 0;

export {
  BA ,
  pi ,
  two_pi ,
  fftInplace ,
  fft ,
  hannWindow ,
  hammingWindow ,
  getMaxAmplitude ,
  generateSineInplace ,
  generateSine ,
  
}
/* pi Not a pure module */
